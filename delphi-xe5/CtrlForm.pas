unit CtrlForm;

interface

uses
  Winapi.Windows, Winapi.Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  StdCtrls, ExtCtrls, ComCtrls,
  IniFiles, Menus, Math, SyncObjs, System.Generics.Collections,
  IdHTTP, XMLDoc, XMLIntf,
  IdContext, IdIntercept, IdServerInterceptLogBase, IdServerInterceptLogFile,
  Dialogs, System.UITypes,
  IdSocketHandle, IdGlobal,
  StrUtils, DateUtils, IdLogBase, IdLogFile,
  ShellAPI, ActiveX, IdExceptionCore, IdUDPBase, IdUDPServer,
  System.UIConsts, IdComponent, IdBaseComponent;

const
  NamikoTrayMessage = WM_USER + 233;

  KEY = 'saf32459090sua0fj23jnroiahfaj23-ir512nmrpaf314';

  L_Console = '控制台';
  L_XMLFile = '文件';
  DET = #9+#9;
  CRLF = #13+#10;

  T_ID = 0;
  T_LTIME = 1;
  //T_RTIME = 1;
  T_TEXT = 2;
  T_SRC = 3;
  T_FORMAT = 4;
  T_DISP = 5;
  T_CYCLE = 6;
  T_OCTIME = 7;
  //T_STATUS = 8;

  SW_BANNED = 128;
  SW_CONSOLE = 64;
  SW_EFFECT = 56;
  SW_E_UFIXED = 16;
  SW_E_DFIXED = 24;
  SW_E_FLYING = 32;
  SW_STATUS = 7;
  SW_S_INIT = 1;
  SW_S_PROC = 2;
  SW_S_WAIT = 3;
  SW_S_DISP = 4;
  SW_S_DONE = 7;

  DEFAULT_NETCOMMENT_DURATION = 5000;
  DEFAULT_NETCOMMENT_MAXDURATION = 8000;

  DEFAULT_UPDATE_INTERVAL = 20;
  DEFAULT_MAX_SCROLL_SPEED = 100;

  DEFAULT_BORDER_WIDTH = 2;
  DEFAULT_BORDER_COLOR = $FF000000; // Pure Black

type
  TNetResult = (OK, BadFormat, BadKey, BadTime, BadData, BadLen, Hexied, IntErr);
// TComment -> TLiveComment -> TRenderUnit
// TCommentCollection -> TLiveCommentCollection -> TRenderUnitQueue

// TComment & TCommentCollection
type
  TAuthorSource = (Internet, Console, XML);
type
  TCommentAuthor = record
    Source: TAuthorSource;
    Address: string;
  end;
type
  TCommentEffectType = (Scroll, UpperFixed, LowerFixed);
type
  TCommentEffect = record
    Display: TCommentEffectType;
    StayTime: SmallInt;
    RepeatCount: SmallInt;
    Speed: SmallInt;
  end;
type
  TCommentFormat = record
    DefaultName: Boolean;
    DefaultSize: Boolean;
    DefaultColor: Boolean;
    DefaultStyle: Boolean;
    FontName: WideString;
    FontSize: Single;
    FontColor: TAlphaColor;
    FontStyle: Integer; // Bitwise OR of TFontStyles
  end;
type
  TCommentStatus = (
    Created,    // [IDLE] Generated, not listed nor dispatched by MAIN THREAD
    Pending,    // [IDLE] Dispatched at least once but not send into TLiveCommentCollection
    Starting,   // [LIVE] Sent to TLiveCommentCollection and just to be rendered
    Waiting,    // [LIVE] Render decided not to draw it due to no channels left etc. Should be RARE
    Displaying, // [LIVE] Rendering and updating cycle
    Removing,   // [LIVE] Marked as displayed by render and render should remove it from TLiveCommentCollection
    Removed     // [IDLE] Marked as displayed or deleted comment and not in TLiveCommentCollection
  );
type
  TComment = class(TObject)
    Time: TTime;
    Content: string;
    Author: TCommentAuthor;
    Format: TCommentFormat;
    Effect: TCommentEffect;
    Status: TCommentStatus;
  protected
    FID: Integer;
    class var MaxID: Integer;
  public
    property ID: Integer read FID;
    constructor Create();
  end;
type
  PComment = ^TComment;
type
  TCommentCollection = TObjectList<TComment>;
type
  PCommentCollection = ^TCommentCollection;
// TLiveComment & TLiveCommentCollection
type
  TLiveCommentStatus = (
    LCreated,   // Generated by dispatcher and not complete
    LWait,      // Not calculated due to limitation
    LMoving,    // Do move/display
    LDelete     // Allow render to remove it
  );
type
  TLiveComment = class(TObject)
    Body: TComment;
    Status: TLiveCommentStatus;
    ChannelLayer: Integer;
    ChannelFrom: Integer;
    ChannelTo: Integer;
    Height: Integer;
    Width: Integer;
    Left: Integer;
    Top: Integer;
    Cycles: Cardinal;
    CycleValue: Cardinal;
  end;
type
  PLiveComment = ^TLiveComment;
type
  TLiveCommentCollection = TObjectList<TLiveComment>;
type
  PLiveCommentCollection = ^TLiveCommentCollection;
// TRenderUnit & TRenderUnitQueue
type
  TRenderUnit = record
    hSrcDC: HDC;
    hDC: HDC;
    hBitmap: HBITMAP;
  end;
type
  TRenderUnitQueue = TQueue<TRenderUnit>;
type
  PRenderUnitQueue = ^TRenderUnitQueue;
// Form
type
  TfrmControl = class(TForm)
    grpCCWindow: TGroupBox;
    btnCCWork: TButton;
    btnCCShow: TButton;
    TimerGeneral: TTimer;
    grpGuestCommentSet: TGroupBox;
    grpOfficialComment: TGroupBox;
    editOfficialComment: TEdit;
    cobNetCFontName: TComboBox;
    cobOfficialCFontName: TComboBox;
    btnOfficialSend: TButton;
    grpSpecialEffects: TRadioGroup;
    editOfficialCommentPara: TLabeledEdit;
    grpTiming: TRadioGroup;
    Statusbar: TStatusBar;
    ListComments: TListView;
    grpComm: TGroupBox;
    radioNetPasv: TRadioButton;
    radioNetPort: TRadioButton;
    editNetPassword: TLabeledEdit;
    editNetPort: TLabeledEdit;
    editNetHost: TLabeledEdit;
    btnOpenFilter: TButton;
    btnSaveComment: TButton;
    btnLoadComment: TButton;
    grpDebug: TGroupBox;
    btnAdmin: TButton;
    Log: TMemo;
    btnExit: TButton;
    cobNetCFontSize: TComboBox;
    cobNetCFontColor: TShape;
    ColorDialog: TColorDialog;
    cobNetCFontBold: TCheckBox;
    cobOfficialCFontSize: TComboBox;
    cobOfficialCFontBold: TCheckBox;
    cobOfficialCFontColor: TShape;
    btnNetStart: TButton;
    SaveDialog: TSaveDialog;
    btnEscAll: TButton;
    btnHideCtrl: TButton;
    EditDispatchKey: THotKey;
    lblCallConsole: TLabel;
    btnSetFixedLabel: TButton;
    editTimingInv: TLabeledEdit;
    editTimingInvUpDown: TUpDown;
    editOfficialCommentParaUpDown: TUpDown;
    editStdShowTime: TLabeledEdit;
    EditStdShowTimeUpDown: TUpDown;
    editOfficialCommentDuration: TLabeledEdit;
    ChkAutoStartNet: TCheckBox;
    btnClearList: TButton;
    TCPLogFile: TIdServerInterceptLogFile;
    radioNetTransmit: TRadioButton;
    editOfficialCommentDurationUpDown: TUpDown;
    EditFetchInv: TLabeledEdit;
    EditFetchInvUpDown: TUpDown;
    BtnFreezing: TButton;
    DelayProgBar: TProgressBar;
    DelayLabel: TLabel;
    EdtNetDelay: TLabeledEdit;
    IdUDPServerCCRecv: TIdUDPServer;
    CheckBox1: TCheckBox;
    EditTimespanDiscarded: TLabeledEdit;
    ButtonTerminateThread: TButton;
    procedure btnCCShowClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure btnCCWorkClick(Sender: TObject);
    procedure FormResize(Sender: TObject);
    procedure TimerGeneralTimer(Sender: TObject);
    procedure btnSetFixedLabelClick(Sender: TObject);
    procedure btnOpenFilterClick(Sender: TObject);
    procedure btnAdminClick(Sender: TObject);
    procedure btnExitClick(Sender: TObject);
    procedure cobNetCFontColorMouseDown(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure cobOfficialCFontColorMouseDown(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure radioNetPortClick(Sender: TObject);
    procedure radioNetPasvClick(Sender: TObject);
    procedure btnOfficialSendClick(Sender: TObject);
    procedure btnLoadCommentClick(Sender: TObject);
    procedure btnSaveCommentClick(Sender: TObject);
    procedure FormCloseQuery(Sender: TObject; var CanClose: Boolean);
    procedure btnHideCtrlClick(Sender: TObject);
    procedure EditDispatchKeyChange(Sender: TObject);
    procedure editNetPortChange(Sender: TObject);
    procedure cobNetCFontSizeKeyPress(Sender: TObject; var Key: Char);
    procedure cobOfficialCFontSizeKeyPress(Sender: TObject; var Key: Char);
    procedure editTimingInvChange(Sender: TObject);
    procedure editStdShowTimeChange(Sender: TObject);
    procedure btnNetStartClick(Sender: TObject);
    procedure cobNetCFontNameChange(Sender: TObject);
    procedure cobNetCFontSizeChange(Sender: TObject);
    procedure cobNetCFontBoldClick(Sender: TObject);
    procedure cobOfficialCFontNameChange(Sender: TObject);
    procedure cobOfficialCFontSizeChange(Sender: TObject);
    procedure cobOfficialCFontBoldClick(Sender: TObject);
    procedure btnEscAllClick(Sender: TObject);
    procedure grpSpecialEffectsClick(Sender: TObject);
    procedure grpTimingClick(Sender: TObject);
    procedure btnClearListClick(Sender: TObject);
    procedure radioNetTransmitClick(Sender: TObject);
    procedure BtnFreezingClick(Sender: TObject);
    procedure ListCommentsDblClick(Sender: TObject);
    procedure ListCommentsKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure editNetPasswordChange(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure EdtNetDelayChange(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure ButtonTerminateThreadClick(Sender: TObject);

  private
    { Private declarations }
    CCWindowShow, CCWindowWorking, Fetching, AddOCWorking : Boolean;
    DispatchKey : Integer;
    HTTPURL : String;
    LastHTTPRequest : Integer;
    XMLDelay : Integer;
    FreezingTime : TTime;

    CommentIndex : Array of TTime;

    procedure WindowTrayMessage(var Message: TMessage);
    message NamikoTrayMessage;
    procedure WMHotKey(var Msg : TWMHotKey); message WM_HOTKEY;

    function GetCommentCount(): Integer;
    procedure CreateCommentWindow();
    procedure StartThreads();
    procedure TerminateThreads();
    procedure LoadSetting();
    procedure SaveSetting();
  public
    { Public declarations }
    TimeZoneBias: Integer;
    RemoteTime, InternalTime, RemoteTimeOffset, InternalTimeOffset : TTime;
    Networking, SysReady, Transmit, Freezing: Boolean;
    CurrListIndex: Cardinal;
    ClearedItemCount: Cardinal;
    // Environment Variables
    ScreenWidth, ScreenHeight: Integer;
    // Internet Runtime Variables
    NetPassword, NetDefaultFontName: string;
    NetDefaultFontSize: Real;
    NetDefaultFontColor: TAlphaColor;
    NetDefaultFontStyle: Cardinal;
    NetDefaultDuration: Integer;
    NetDelayDuration: Integer;
    // Official Runtime Variables
    OfficialFontName: string;
    OfficialFontSize: Real;
    OfficialFontColor: TAlphaColor;
    OfficialFontStyle: Cardinal;
    OfficialDuration: Integer;
    OfficialRepeat: Integer;
    // Title Variables
    MTitleText: string;
    MTitleTop, MTitleLeft: Integer;
    MTitleFontName: WideString;
    MTitleFontSize: Single;
    MTitleFontColor: TAlphaColor;
    // CONTAINERS <<SHOULD BE FREED MANUALLY>>
    CommentPool: TCommentCollection;
    LiveCommentPool: TLiveCommentCollection;
    UpdateQueue: TRenderUnitQueue;
    // TListView Wrapper
    ListViewOffset: Integer;
    // New Procedures
    procedure UpdateListView(const CommentID: Integer); // called by AppendListView
    procedure AppendListView(const AComment: TComment);
    procedure AppendComment(var AComment: TComment); // MUTEX, called by AppendXComment()
    procedure AppendNetComment(LTime: TTime; RTime: TTime; Author: TCommentAuthor; AContent: string; AFormat: TCommentFormat);
    procedure AppendConsoleComment(AContent: string; AEffect: TCommentEffect; AFormat: TCommentFormat);
    procedure AppendLocalComment(LTime: TTime; RTime: TTime; AContent: string; AEffect: TCommentEffect; AFormat: TCommentFormat);
    // Old Procedures
    procedure LogEvent(Info: WideString);
  end;

var
  frmControl: TfrmControl;
  APP_DIR, NamikoKey: string; // Shared with other units
  TrayIconData: TNotifyIconData;
  // Thread Sync Objects
  SharedConfigurationMutex, GraphicSharedMutex, CommentPoolMutex, LiveCommentPoolMutex, UpdateQueueMutex: TMutex;
  DispatchS, UpdateS: TSemaphore;
  DefaultSA: TSecurityAttributes; // Use to create thread objects
  // Comment Layered Window
  CCWnd,hInst: THandle;
  CCWinClass: TWndClassEx; // WNDCLASSEX wndcls;
  CCWinPos: TRect;

function EncrypKey(Src:String; Key:String): String;
function UncrypKey(Src:String; Key:String): String;

function ShiftStateToInt(Shift: TShiftState): Cardinal;

implementation

{$R *.dfm}
uses
  UDPHandleThread, RenderThread, UpdateThread, DispatchThread, IGDIPlusEmbedded;

var
  RThread: TRenderThread;
  UThread: TUpdateThread;
  DThread: TDispatchThread;

constructor TComment.Create;
begin
  inherited Create();
  Inc(MaxID);
  Self.FID := MaxID;
end;

procedure TfrmControl.AppendListView(const AComment: TComment);
begin
  with ListComments.Items.Add do begin
    Caption := 'C';
    SubItems.Add(IntToStr(AComment.ID));
    SubItems.Add(Format('%s.%u',[TimeToStr(AComment.Time),MilliSecondOf(AComment.Time)]));
    SubItems.Add(AComment.Content);
    case AComment.Author.Source of
      Internet: SubItems.Add(AComment.Author.Address);
      Console: SubItems.Add(L_Console);
      XML: SubItems.Add(L_XMLFile);
    end;
    SubItems.Add(Format('%s|%.1f|%s|%s',[AComment.Format.FontName,AComment.Format.FontSize,IntToHex(AComment.Format.FontColor,8),IfThen(AComment.Format.FontStyle = 1,'B','R')]));
    case AComment.Effect.Display of
      Scroll: SubItems.Add('飞行');
      UpperFixed: SubItems.Add('上固');
      LowerFixed: SubItems.Add('下固');
    end;
    SubItems.Add(IntToStr(AComment.Effect.RepeatCount));
    SubItems.Add(IntToStr(AComment.Effect.StayTime));
  end;
end;

procedure TfrmControl.UpdateListView(const CommentID: Integer);
var
  AComment: TComment;
  Index: Integer;
begin
  if CommentID > CommentPool.Count then Exit;
  Index := CommentID - ListViewOffset - 1;
  if Index > ListComments.Items.Count then Exit;
  AComment := CommentPool.Items[Index];
  //if StrToInt(ListComments.Items[Index].SubItems.Strings[T_ID]) = CommentID then begin // Out of range
  case AComment.Status of
    Created: ListComments.Items.Item[Index].Caption := 'C';
    Pending: ListComments.Items.Item[Index].Caption := 'P';
    Starting: ListComments.Items.Item[Index].Caption := 'S';
    Waiting: ListComments.Items.Item[Index].Caption := 'W';
    Displaying: ListComments.Items.Item[Index].Caption := '<';
    Removing: ListComments.Items.Item[Index].Caption := 'R';
    Removed: ListComments.Items.Item[Index].Caption := 'D';
  end;
  //end;
end;

procedure TfrmControl.AppendComment(var AComment: TComment);
begin
  AppendListView(AComment);
  // Do not change these two lines
  AComment.Content := StringReplace(AComment.Content,'\n',#13,[rfReplaceAll]);
  AComment.Content := StringReplace(AComment.Content,'/n',#13,[rfReplaceAll]);
  CommentPoolMutex.Acquire; // CS: Read the comment pool
  try
    // Main Proc to complete this operation
    CommentPool.Add(AComment);
  finally
    CommentPoolMutex.Release;
  end;
  DispatchS.Release;
end;

procedure TfrmControl.AppendNetComment(LTime: TTime; RTime: TTime; Author: TCommentAuthor; AContent: string; AFormat: TCommentFormat);
var
  ThisComment: TComment;
begin
  ThisComment := TComment.Create;
  ThisComment.Time := LTime + NetDelayDuration / 86400000; // TODO
  ThisComment.Content := AContent;
  ThisComment.Author := Author;
  ThisComment.Format := AFormat;
  with ThisComment.Format do begin
    if DefaultName then FontName := NetDefaultFontName;
    if DefaultSize then FontSize := NetDefaultFontSize;
    if DefaultColor then FontColor := NetDefaultFontColor;
    if DefaultStyle then FontStyle := NetDefaultFontStyle;
  end;
  with ThisComment.Effect do begin
    Display := Scroll;
    StayTime := NetDefaultDuration;
    RepeatCount := 1;
    Speed := 0;
  end;
  ThisComment.Status := Created;
  AppendComment(ThisComment);
end;

procedure TfrmControl.AppendConsoleComment(AContent: string; AEffect: TCommentEffect; AFormat: TCommentFormat);
var
  ThisComment: TComment;
begin
  ThisComment := TComment.Create;
  ThisComment.Time := Now(); // TODO
  ThisComment.Content := AContent;
  ThisComment.Author.Source := Console;
  ThisComment.Format := AFormat;
  ThisComment.Effect := AEffect;
  ThisComment.Status := Created;
  AppendComment(ThisComment);
end;

procedure TfrmControl.AppendLocalComment(LTime: TTime; RTime: TTime; AContent: string; AEffect: TCommentEffect; AFormat: TCommentFormat);
var
  ThisComment: TComment;
begin

  AppendComment(ThisComment);
end;

procedure TfrmControl.btnCCShowClick(Sender: TObject);
begin
  if CCWindowShow then begin
    CCWindowShow := false;
    btnCCShow.Caption := '显示(&S)';
  end
  else begin
    CCWindowShow := true;
    btnCCShow.Caption := '隐藏(&H)';
  end;
end;

procedure TfrmControl.WindowTrayMessage(var Message: TMessage);
begin
  if Message.Msg = NamikoTrayMessage then begin
    case Message.LParam of
      WM_LBUTTONUP:
      begin
        ShowWindow(Self.Handle,SW_NORMAL);
        SetForegroundWindow(Self.Handle);
      end;
    end;
  end;
end;

procedure TfrmControl.CreateCommentWindow;
var
  hdcTemp,hdcScreen,m_hdcMemory: HDC;
  hBitMap: Winapi.Windows.HBITMAP;
  blend: BLENDFUNCTION;      //这种结构的混合控制通过指定源和目标位图的混合功能
  ptWinPos,ptSrc: TPoint;
  sizeWindow: SIZE;
begin
  if CCWnd > 0 then Exit; // Already Created
  hInst := GetModuleHandle(nil); // HINSTANCE hInstance=AfxGetInstanceHandle();
  CCWinClass.cbSize := SizeOf(TWndClassEx); // wndcls.cbSize=sizeof(WNDCLASSEX);
  CCWinClass.lpszClassName := 'MyLayeredWindow'; // wndcls.lpszClassName=lpszClassName;
  CCWinClass.style := CS_DBLCLKS or CS_HREDRAW or CS_VREDRAW; //wndcls.style=CS_DBLCLKS|CS_HREDRAW|CS_VREDRAW;
  CCWinClass.hInstance := hInst; //wndcls.hInstance=hInstance;
  CCWinClass.lpfnWndProc := @DefWindowProc; //wndcls.lpfnWndProc=::DefWindowProc;
  CCWinClass.cbClsExtra := 0; //以下两个域用于在类结构和Windows内部保存的窗口结构
  CCWinClass.cbWndExtra := 0; //中预留一些额外空间.
  CCWinClass.hIcon := 0; // wndcls.hIcon=NULL;
  CCWinClass.hIconsm := 0;
  CCWinClass.hCursor := LoadCursor(0,IDC_Arrow); // wndcls.hCursor=::LoadCursor(NULL,IDC_ARROW);
  //GetStockObject 获取一个图形对象,在这里是获取绘制窗口背景的刷子,返回一个白色刷  子的句柄.
  CCWinClass.hbrBackground := HBRUSH(COLOR_BTNFACE+1); // wndcls.hbrBackground=(HBRUSH)(COLOR_BTNFACE+1);
  CCWinClass.lpszMenuName := nil; //wndcls.lpszMenuName=NULL;

  //向Windows 注册窗口类.
  if RegisterClassEx(CCWinClass) = 0 then begin
    LogEvent('弹幕窗体类注册失败');
    Exit;
  end;

  CCWnd := CreateWindowEx(
    WS_EX_TOOLWINDOW or WS_EX_TOPMOST or WS_EX_LAYERED, //扩展的窗口风格.
    CCWinClass.lpszClassName, //类名.
    'Hello Window', //窗口标题.
    WS_POPUP or WS_VISIBLE, //窗口风格.
    CCWinPos.Left, //窗口左上角相对于屏幕左上角的初始位置x.
    CCWinPos.Top, //....右y.
    CCWinPos.Width, //窗口宽度x.
    CCWinPos.Height, //窗口高度y.
    0, //父窗口句柄.
    0, //窗口菜单句柄.
    hInst, //程序实例句柄.
    nil); //创建参数指针.
  if CCWnd = 0 then
    LogEvent('弹幕窗体创建失败')
  else
  begin
    hdcTemp := GetDC(CCWnd);
    m_hdcMemory := CreateCompatibleDC(hdcTemp);
    hBitMap := CreateCompatibleBitmap(hdcTemp,CCWinPos.Width,CCWinPos.Height);
    SelectObject(m_hdcMemory,hBitMap);
    with blend do begin
      BlendOp := AC_SRC_OVER;     //把源图片覆盖到目标之上
      BlendFlags := 0;
      AlphaFormat := AC_SRC_ALPHA;//每个像素有各自的alpha通道
      SourceConstantAlpha :=Trunc(100 * 2.55);  //源图片的透明度
    end;
    ptWinPos := Point(0,0);
    sizeWindow.cx := CCWinPos.Width;
    sizeWindow.cy := CCWinPos.Height;
    ptSrc := Point(0,0);
    hdcScreen := GetDC(CCWnd);
    UpdateLayeredWindow(CCWnd,   //分层窗口的句柄
                        hdcScreen,     //屏幕的DC句柄
                        @ptWinPos,     //分层窗口新的屏幕坐标
                        @sizeWindow,   //分层窗口新的大小
                        m_hdcMemory,   //用来定义分层窗口的表面DC句柄
                        @ptSrc,        //分层窗口在设备上下文的位置
                        0,             //合成分层窗口时使用指定颜色键值
                        @blend,        //在分层窗口进行组合时的透明度值
                        ULW_ALPHA);    //使用pblend为混合功能
    //---------------------开始：释放和删除--------------------------------------
    ReleaseDC(CCWnd,hdcScreen);
    ReleaseDC(CCWnd,hdcTemp);
    DeleteObject(hBitMap);
    DeleteDC(m_hdcMemory);
  end;
end;

procedure TfrmControl.StartThreads;
var
  CreateD, CreateR, CreateU: Boolean;
begin
  if not SysReady then begin
    LogEvent('未就绪状态，无法启动线程');
    Exit;
  end;
  CreateD := True;
  CreateR := True;
  CreateU := True;
  if Assigned(DThread) then begin
    if DThread.Finished then
      DThread.Free()
    else
      CreateD := False;
  end;
  if CreateD then begin
    DThread := TDispatchThread.Create(30000,300,CommentPool,LiveCommentPool);
    LogEvent('创建调度线程');
    DThread.Start;
  end;
  if Assigned(RThread) then begin
    if RThread.Finished then
      RThread.Free()
    else
      CreateR := False;
  end;
  if CreateR then begin
    RThread := TRenderThread.Create(CCWnd,CCWinPos.Width,CCWinPos.Height,LiveCommentPool,UpdateQueue);
    LogEvent('创建绘制线程');
    RThread.Start;
  end;
  if Assigned(UThread) then begin
    if UThread.Finished then
      UThread.Free()
    else
      CreateU := False;
  end;
  if CreateU then begin
    UThread := TUpdateThread.Create(CCWnd,CCWinPos,UpdateQueue);
    LogEvent('创建显示线程');
    UThread.Start;
  end;
end;

procedure TfrmControl.TerminateThreads;
begin
  if Assigned(DThread) and DThread.Started then DThread.Terminate;
  if Assigned(RThread) and RThread.Started then RThread.Terminate;
  if Assigned(UThread) and UThread.Started then begin
    UpdateS.Release; // Empty Operation
    UThread.Terminate;
  end;
end;

procedure TfrmControl.FormCreate(Sender: TObject);
var
  Key : Word;
  Shift : TShiftState;
  m_timezone : TIME_ZONE_INFORMATION;
begin
  LogEvent('主窗体开始加载');
  ScreenWidth := GetSystemMetrics(SM_CXSCREEN);
  ScreenHeight := GetSystemMetrics(SM_CYSCREEN);
  LogEvent(Format('获取屏幕大小 %u*%u',[ScreenWidth,ScreenHeight]));
  //Init Interface
  StatusBar.Panels[0].Width := Width - 610;
  StatusBar.Panels[2].Text := '显示/总共 0/0';
  {$IFNDEF DEBUG}
  Width := 870;
  Constraints.MaxWidth := 870;
  {$ENDIF}
  //Set Variable & UI
  CCWindowShow := False;
  CCWindowWorking := False;
  Networking := False;
  Transmit := False;
  Fetching := False;
  Freezing := False;
  AddOCWorking := False;
  CurrListIndex := 0;
  ClearedItemCount := 0;
  XMLDelay := 0;
  ListViewOffset := 0;
  //Set Internal Time as System Time
  InternalTime := Time();
  InternalTimeOffset := 0;
  //Set Timezone
  GetTimeZoneInformation(m_timezone);
  TimeZoneBias := m_timezone.Bias * 60;
  LogEvent(Format('获取时区偏移 %u',[TimeZoneBias]));
  LastHTTPRequest := DateTimeToUnix(Now())+TimeZoneBias;
  //Fetch Font List
  cobNetCFontName.Items.AddStrings(Screen.Fonts);
  cobOfficialCFontName.Items.AddStrings(Screen.Fonts);
  //Load Settings
  APP_DIR := ExtractFilePath(ParamStr(0));
  LoadSetting(); // Call After APP_DIR
  LogEvent('读取配置文件');
  //Set Path
  SaveDialog.InitialDir := APP_DIR;
  TCPLogFile.Filename := APP_DIR+'TCPServer.log';
  //HTTPLog.Filename := APP_DIR+'HTTPClient.log';
  //Register Hotkey
  try
    ShortCutToKey(EditDispatchKey.HotKey,Key,Shift);
    DispatchKey := GlobalAddAtom('RTCCDispatchHotkey');
    RegisterHotKey(handle,DispatchKey,ShiftStateToInt(Shift),Key);
    LogEvent('注册快捷键');
  except
    LogEvent('[异常] 快捷键设置失败');
  end;
  //Register Tray Icon
  TrayIconData.cbSize := SizeOf(TrayIconData);
  TrayIconData.uFlags := NIF_ICON or NIF_TIP or NIF_MESSAGE;
  TrayIconData.uID := UINT(Self);
  TrayIconData.Wnd := Handle;
  TrayIconData.hIcon := Application.Icon.Handle;
  StrCopy(@TrayIconData.szTip,PChar(Application.Title));
  TrayIconData.uCallbackMessage := NamikoTrayMessage;
  Shell_NotifyIcon(NIM_ADD,@TrayIconData);
  LogEvent('创建托盘图标');
  //Pools
  CommentPool := TCommentCollection.Create(True);
  CommentPoolMutex.Release;
  LiveCommentPool := TLiveCommentCollection.Create(True);
  LiveCommentPoolMutex.Release;
  UpdateQueue := TRenderUnitQueue.Create();
  UpdateQueue.Capacity := 256;
  UpdateQueueMutex.Release;
  LogEvent('创建弹幕池和临时空间');
  CreateCommentWindow;
  if CCWnd = 0 then begin
    Application.MessageBox('弹幕窗体创建失败，将无法正常工作。','启动异常',MB_ICONERROR);
  end
  else begin
    LogEvent('创建弹幕窗体完成');
    SysReady := True;
    // Thread
    StartThreads;
    // IMPORTANT!
    SharedConfigurationMutex.Release;
    GraphicSharedMutex.Release;
    //Notify Complete
    LogEvent('初始化完毕');
    StatusBar.Panels[0].Text := '控制台初始化完毕';
  end;
 end;

procedure TfrmControl.FormDestroy(Sender: TObject);
begin
  SysReady := False;
  SaveSetting();
  Shell_NotifyIcon(NIM_DELETE,@TrayIconData);
  UnRegisterHotKey(handle,DispatchKey);
  GlobalDeleteAtom(DispatchKey);
  DThread.Free;
  RThread.Free;
  UThread.Free;
  CommentPoolMutex.Acquire;
  CommentPool.Free;
  CommentPoolMutex.Release;
  LiveCommentPoolMutex.Acquire;
  LiveCommentPool.Free;
  LiveCommentPoolMutex.Release;
  UpdateQueueMutex.Acquire;
  UpdateQueue.Free;
  UpdateQueueMutex.Release;
  if CCWnd > 0 then DestroyWindow(CCWnd);
end;

procedure TfrmControl.btnCCWorkClick(Sender: TObject);
begin
  if CCWindowWorking then begin
    CCWindowWorking := false;
    btnCCWork.Caption := '隐藏弹幕示例(&W)';
    {with frmComment do begin
      BorderStyle := bsSizeable;
      TransparentColor := False;
      NetCDemo.Visible := True;
      OfficialCDemo.Visible := True;
    end;}

  end
  else begin
    CCWindowWorking := true;
    btnCCWork.Caption := '显示弹幕样例(&I)';
    {with frmComment do begin
      BorderStyle := bsNone;
      TransparentColor := True;
      NetCDemo.Visible := False;
      OfficialCDemo.Visible := False;
    end;}
  end;
end;

procedure TfrmControl.FormResize(Sender: TObject);
begin
  StatusBar.Panels[0].Width := Width - 610;
end;

procedure TfrmControl.TimerGeneralTimer(Sender: TObject);
begin
  {case grpTiming.ItemIndex of
    0: InternalTime := Time();
    1,2: if not Freezing then InternalTime := InternalTime + TimerGeneral.Interval / 86400000;
  end;
  if RemoteTime <> 0 then RemoteTime := RemoteTime + TimerGeneral.Interval / 86400000;}
  StatusBar.Panels[1].Text := Format('当前显示 %u',[0]);
  StatusBar.Panels[2].Text := Format('已显示/总共 %u/%u',[0,0]);
  StatusBar.Panels[3].Text := '内部 '+TimeToStr(InternalTime);
  StatusBar.Panels[4].Text := '远程 '+Ifthen(Boolean(RemoteTime = 0),'未知',TimeToStr(RemoteTime));
  StatusBar.Panels[5].Text := '本地 '+TimeToStr(Time());
end;

procedure TfrmControl.btnSetFixedLabelClick(Sender: TObject);
begin
  //TestLabel.Font := OfficialCDemo.Font;
  MTitleText := StringReplace(editOfficialComment.Text,'/n',#13,[rfReplaceAll]);
end;

procedure TfrmControl.ButtonTerminateThreadClick(Sender: TObject);
begin
  TerminateThreads;
end;

procedure TfrmControl.btnOpenFilterClick(Sender: TObject);
begin
  //frmWordList.Show;
end;

procedure TfrmControl.btnAdminClick(Sender: TObject);
begin
  if InputBox('管理模式','请输入密码　　','') = 'CT10' then begin
    Constraints.MaxWidth := 1180;
    Width := 1180;
    btnAdmin.Visible := False;
  end;
end;

procedure TfrmControl.btnExitClick(Sender: TObject);
begin
  // Unloading
  frmControl.Close;
end;

procedure TfrmControl.cobNetCFontColorMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  ColorDialog.Color := cobNetCFontColor.Brush.Color;
  if ColorDialog.Execute then begin
    cobNetCFontColor.Brush.Color := ColorDialog.Color;
    NetDefaultFontColor := ColorDialog.Color or $FF000000;
  end;
end;

procedure TfrmControl.cobOfficialCFontColorMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  ColorDialog.Color := cobOfficialCFontColor.Brush.Color;
  if ColorDialog.Execute then begin
    cobOfficialCFontColor.Brush.Color := ColorDialog.Color;
    OfficialFontColor := ColorDialog.Color or $FF000000;
  end;
end;

procedure TfrmControl.radioNetPortClick(Sender: TObject);
begin
  radioNetPort.Checked := true;
  editNetHost.Enabled := true;
  editNetPort.Enabled := false;
end;

procedure TfrmControl.radioNetPasvClick(Sender: TObject);
begin
  radioNetPasv.Checked := true;
  editNetHost.Enabled := false;
  editNetPort.Enabled := true;
end;

procedure TfrmControl.btnOfficialSendClick(Sender: TObject);
var
  Content: string;
  Effect: TCommentEffect;
  Format: TCommentFormat;
begin
  Content := TrimRight(editOfficialComment.Text);
  if Length(Content) = 0 then Exit;
  {if frmWordList.Hexied(Content) then begin
    if Application.MessageBox('检测到敏感词，继续吗？','河蟹已经阻止不了你了么',MB_ICONQUESTION + MB_YESNO) = IDNO then begin
      editOfficialComment.Clear;
      editOfficialComment.SetFocus;
      exit;
    end;
  end;}

  case grpSpecialEffects.ItemIndex of
    0: Effect.Display := Scroll;
    1: Effect.Display := UpperFixed;
    2: Effect.Display := LowerFixed;
  end;
  Effect.StayTime := StrToInt(editOfficialCommentDuration.Text);
  Effect.RepeatCount := IfThen(Boolean(Effect.Display = Scroll),StrToInt(editOfficialCommentPara.Text),1);

  Format.DefaultName := False;
  Format.DefaultSize := False;
  Format.DefaultColor := False;
  Format.DefaultStyle := False;
  Format.FontName := OfficialFontName;
  Format.FontSize := OfficialFontSize;
  Format.FontColor := OfficialFontColor; // TColor To TAlphaColor
  Format.FontStyle := OfficialFontStyle;
  {Format.FontColor := Color or $FF000000; // TColor To TAlphaColor
  Format.FontStyle := IfThen(fsBold in Style,1,0);}

  AppendConsoleComment(Content,Effect,Format);

  editOfficialComment.Clear;
  editOfficialComment.SetFocus;
end;

procedure TfrmControl.btnLoadCommentClick(Sender: TObject);
begin
  //frmLoadXML.Show();
  //frmLoadXML.Test;
end;

procedure TfrmControl.btnSaveCommentClick(Sender: TObject);
var
  XMLDoc : TXMLDocument;
  DocIntf : IXMLDocument;
  RootNode, CNode : IXMLNode;
  i : Integer;
begin
  if SaveDialog.Execute then begin
    XMLDoc := TXMLDocument.Create(nil);
    try
      DocIntf := XMLDoc;
      try
        XMLDoc.Active := true;
        XMLDoc.Encoding := 'utf-8';
        XMLDoc.Options := XMLDoc.Options + [doNodeAutoIndent];
        RootNode := XMLDoc.AddChild('Namiko');
        for i := 0 to CommentPool.Count - 1 do begin
          CNode := RootNode.AddChild('comment');
          // Read CommentPool instead
          {with ListComments.Items.Item[i].SubItems do begin
            CNode.AddChild('time').Text := Strings[T_LTIME];
            CNode.AddChild('content').Text := Strings[T_TEXT];
            CNode.AddChild('format').Text := Strings[T_FORMAT];
            CNode.AddChild('repeat').Text := Strings[T_CYCLE];
            CNode.AddChild('duration').Text := Strings[T_OCTIME];
            CNode.AddChild('data').Text := Strings[T_STATUS];
          end;}
        end;
        XMLDoc.SaveToFile(SaveDialog.FileName);
      except
        LogEvent('有异常发生 自行检查是否保存成功（拖');
        DocIntf := nil;
      end;
    finally
      XMLDoc.Free;
    end;
  end;
end;

procedure TfrmControl.LogEvent(Info: WideString);
begin
  StatusBar.Panels[0].Text := Info;
  Log.Lines.Add(TimeToStr(Now())+' '+Info);
  Log.Lines.SaveToFile(APP_DIR+'Namiko.log');
end;

procedure TfrmControl.LoadSetting();
var
  ini : TCustomIniFile;
begin
  ini := TINIFile.Create(APP_DIR+'Settings.ini');
  // Internet Comment Format
  cobNetCFontName.ItemIndex := cobNetCFontName.Items.IndexOf(ini.ReadString('NetComment','FontName','微软雅黑'));
  NetDefaultFontName := ini.ReadString('NetComment','FontName','微软雅黑');
  cobNetCFontSize.Text := ini.ReadString('NetComment','FontSize','18');
  NetDefaultFontSize := StrToFloat(cobNetCFontSize.Text);
  cobNetCFontColor.Brush.Color := StringToColor(ini.ReadString('NetComment','FontColor','clWhite'));
  NetDefaultFontColor := StringToAlphaColor(ini.ReadString('NetComment','FontColor','clWhite'));
  cobNetCFontBold.Checked := ini.ReadBool('NetComment','FontBold',false);
  if cobNetCFontBold.Checked then NetDefaultFontStyle := 1 else NetDefaultFontStyle := 0;
  // Official Comment Format
  cobOfficialCFontName.ItemIndex := cobOfficialCFontName.Items.IndexOf(ini.ReadString('OfficialComment','FontName','微软雅黑'));
  OfficialFontName := ini.ReadString('OfficialComment','FontName','微软雅黑');
  cobOfficialCFontSize.Text := ini.ReadString('OfficialComment','FontSize','26');
  OfficialFontSize := StrToFloat(cobOfficialCFontSize.Text);
  cobOfficialCFontColor.Brush.Color := StringToColor(ini.ReadString('OfficialComment','FontColor','clBlue'));
  OfficialFontColor := StringToAlphaColor(ini.ReadString('OfficialComment','FontColor','clWhite'));
  cobOfficialCFontBold.Checked := ini.ReadBool('OfficialComment','FontBold',True);
  if cobOfficialCFontBold.Checked then OfficialFontStyle := 1 else OfficialFontStyle := 0;
  // Window Position
  CCWinPos := TRect.Create(
    ini.ReadInteger('Display','WorkWindowLeft',0),
    ini.ReadInteger('Display','WorkWindowTop',0),
    ini.ReadInteger('Display','WorkWindowWidth',ScreenWidth),
    ini.ReadInteger('Display','WorkWindowHeight',ScreenHeight div 2));
  // Prompt Caption
  MTitleText := ini.ReadString('Display','TitleText','TEST');
  MTitleTop := ini.ReadInteger('Display','TitleTop',0);
  MTitleLeft := ini.ReadInteger('Display','TitleLeft',ScreenWidth div 2);
  MTitleFontName := ini.ReadString('Display','TitleFontName','微软雅黑');
  MTitleFontSize := ini.ReadFloat('Display','TitleFontSize',18.0);
  MTitleFontColor := StringToAlphaColor(ini.ReadString('Display','TitleColor','clTeal'));
  // Network Config
  {if ini.ReadBool('Connection','Transmit',false) then begin
    radioNetTransmit.OnClick(self);
  else begin}
  if ini.ReadBool('Connection','Passive',true) then radioNetPasv.OnClick(Self) else radioNetPort.OnClick(Self);
  editNetPort.Text := ini.ReadString('Connection','Port','7233');
  editNetHost.Text := ini.ReadString('Connection','Host','http://127.0.0.1/fetchcomment.php');
  chkAutoStartNet.Checked := ini.ReadBool('Connection','AutoStart',false);
  //TimerFetch.Interval := ini.ReadInteger('Connection','Interval',1000);
  EditFetchInv.Text := ini.ReadString('Connection','Interval','1000');

  NetDefaultDuration := ini.ReadInteger('Timing','DefaultCommentShowTime',DEFAULT_NETCOMMENT_DURATION);
  try
    editNetPassword.Text := UncrypKey(ini.ReadString('Connection','Key','UNDEF'),KEY);
  except
    editNetPassword.Text := '233-614-789-998';
    LogEvent('通信密码未设置！');
  end;
  NetPassword := editNetPassword.Text;
  // Other Parameters
  
  ini.Free;
end;

procedure TfrmControl.SaveSetting();
var
  ini : TCustomIniFile;
begin
  ini := TINIFile.Create(APP_DIR+'Settings.ini');

  ini.WriteString('NetComment','FontName',cobNetCFontName.Items.Strings[cobNetCFontName.ItemIndex]);
  ini.WriteString('NetComment','FontSize',cobNetCFontSize.Text);
  ini.WriteString('NetComment','FontColor',ColorToString(cobNetCFontColor.Brush.Color));
  ini.WriteBool('NetComment','FontBold',cobNetCFontBold.Checked);

  ini.WriteString('OfficialComment','FontName',cobOfficialCFontName.Items.Strings[cobOfficialCFontName.ItemIndex]);
  ini.WriteString('OfficialComment','FontSize',cobOfficialCFontSize.Text);
  ini.WriteString('OfficialComment','FontColor',ColorToString(cobOfficialCFontColor.Brush.Color));
  ini.WriteBool('OfficialComment','FontBold',cobOfficialCFontBold.Checked);

  ini.WriteBool('Connection','Transmit',radioNetTransmit.Checked);
  ini.WriteBool('Connection','Passive',radioNetPasv.Checked);
  ini.WriteString('Connection','Port',editNetPort.Text);
  ini.WriteString('Connection','Host',editNetHost.Text);
  ini.WriteString('Connection','Key',EncrypKey(editNetPassword.Text,KEY));
  ini.WriteBool('Connection','AutoStart',ChkAutoStartNet.Checked);
  //ini.WriteInteger('Connection','Interval',TimerFetch.Interval);
  ini.WriteInteger('Display','WorkWindowLeft',CCWinPos.Left);
  ini.WriteInteger('Display','WorkWindowTop',CCWinPos.Top);
  ini.WriteInteger('Display','WorkWindowWidth',CCWinPos.Width);
  ini.WriteInteger('Display','WorkWindowHeight',CCWinPos.Height);

  ini.WriteString('Display','TitleText',MTitleText);
  ini.WriteInteger('Display','TitleTop',MTitleTop);
  ini.WriteInteger('Display','TitleLeft',MTitleLeft);
  ini.WriteString('Display','TitleFontName',MTitleFontName);
  ini.WriteFloat('Display','TitleFontSize',MTitleFontSize);
  ini.WriteString('Display','TitleColor',AlphaColorToString(MTitleFontColor));

  ini.Free;
end;

function EncrypKey(Src:string; Key:string): string;
var
  KeyLen,KeyPos: Integer;
  offset: Integer;
  dest: string;
  SrcPos,SrcAsc,Range: Integer;
begin
  KeyLen := Length(Key);
  if KeyLen = 0 then Key := '233acgrid998';
  KeyPos := 0;
  Range := 256;

  Randomize;
  offset := Random(Range);
  dest := format('%1.2x',[offset]);
  for SrcPos := 1 to Length(Src) do begin
    SrcAsc := (Ord(Src[SrcPos]) + offset) mod 255;
    if KeyPos < KeyLen then KeyPos := KeyPos + 1 else KeyPos:=1;
    SrcAsc := SrcAsc xor Ord(Key[KeyPos]);
    dest := dest + format('%1.2x',[SrcAsc]);
    offset := SrcAsc;
  end;
  Result := dest;
end;

function UncrypKey(Src:string; Key:string): string;
var
  KeyLen,KeyPos: Integer;
  offset: Integer;
  dest: string;
  SrcPos,SrcAsc,TmpSrcAsc: Integer;
begin
  KeyLen := Length(Key);
  if KeyLen = 0 then key := '233acgrid998';
  KeyPos := 0;
  offset := StrToInt('$'+ Copy(src,1,2));
  SrcPos := 3;
  repeat
    SrcAsc := StrToInt('$'+ Copy(src,SrcPos,2));
    if KeyPos < KeyLen then KeyPos := KeyPos + 1 else KeyPos := 1;
    TmpSrcAsc := SrcAsc xor Ord(Key[KeyPos]);
    if TmpSrcAsc <= offset then
      TmpSrcAsc := 255 + TmpSrcAsc - offset
    else
      TmpSrcAsc := TmpSrcAsc - offset;
    dest := dest + chr(TmpSrcAsc);
    offset := srcAsc;
    SrcPos := SrcPos + 2;
  until SrcPos >= Length(Src);
  Result := Dest;
end;

procedure TfrmControl.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  TerminateThreads;
end;

procedure TfrmControl.FormCloseQuery(Sender: TObject;
  var CanClose: Boolean);
begin
  {$IFNDEF DEBUG}
  if btnAdmin.Visible then begin
    CanClose := false;
    StatusBar.Panels[0].Text := '关你妹';
    exit;
  end;
  CanClose := Boolean(Application.MessageBox('确认?','退出',MB_ICONQUESTION+MB_YESNO) = IDYES);
  {$ENDIF}
end;

procedure TfrmControl.btnHideCtrlClick(Sender: TObject);
begin
  SetWindowPos(Self.Handle,HWND_NOTOPMOST,Self.Left,Self.Top,Self.Width,Self.Height,SWP_NOACTIVATE);
  Self.Hide;
end;

procedure TfrmControl.EditDispatchKeyChange(Sender: TObject);
var
  Key : Word;
  Shift : TShiftState;
begin
  try
    UnRegisterHotKey(handle,DispatchKey);
    GlobalDeleteAtom(DispatchKey);
    ShortCutToKey(EditDispatchKey.HotKey,Key,Shift);
    DispatchKey := GlobalAddAtom('RTCCDispatchHotkey');
    RegisterHotKey(handle,DispatchKey,ShiftStateToInt(Shift),Key);
  except on E: Exception do
    LogEvent('[异常] 快捷键设置失败: '+E.Message);
  end;
end;

procedure TfrmControl.WMHotKey(var Msg : TWMHotKey);  //HOTKEY DISPATCHER
begin
  if Msg.HotKey = DispatchKey then begin
    frmControl.Left := 0;
    frmControl.Show;
  end;
end;

function ShiftStateToInt(Shift: TShiftState): Cardinal;
begin
  Result := 0;
  if ssShift in Shift then Result := Result + MOD_SHIFT;
  if ssAlt in Shift then Result := Result + MOD_ALT;
  if ssCtrl	in Shift then Result := Result + MOD_CONTROL;
end;

procedure TfrmControl.editNetPasswordChange(Sender: TObject);
begin
  SharedConfigurationMutex.Acquire;
  try
    NetPassword := editNetPassword.Text;
  finally
    SharedConfigurationMutex.Release;
  end;
end;

procedure TfrmControl.editNetPortChange(Sender: TObject);
var
  Port : Integer;
begin
  Port := StrToIntDef(editNetPort.Text,65536);
  if (Port <= 0) or (Port > 65535) then begin
    editNetPort.Text := '9233';
    Application.MessageBox('端口号范围：1-65535。','错误',MB_ICONEXCLAMATION);
  end;
end;

procedure TfrmControl.cobNetCFontSizeKeyPress(Sender: TObject;
  var Key: Char);
begin
  if not CharInSet(Key,['0'..'9', #8, #13, #27]) then Key := #0;
end;

procedure TfrmControl.cobOfficialCFontSizeKeyPress(Sender: TObject;
  var Key: Char);
begin
  if not CharInSet(Key,['0'..'9', #8, #13, #27]) then Key := #0;
end;

procedure TfrmControl.editTimingInvChange(Sender: TObject);
begin
  //frmComment.TimerMoving.Interval := StrToIntDef(editTimingInv.Text,50);
end;

procedure TfrmControl.EdtNetDelayChange(Sender: TObject);
begin
  NetDelayDuration := StrToIntDef(EdtNetDelay.Text,3000);
end;

procedure TfrmControl.editStdShowTimeChange(Sender: TObject);
begin
  NetDefaultDuration := StrToIntDef(EditStdShowTime.Text,DEFAULT_NETCOMMENT_DURATION);
end;

procedure TfrmControl.btnNetStartClick(Sender: TObject);
var
  bind : TIdSocketHandle;
  port : Integer;
begin
  if Networking then begin
    if Transmit then begin
      editNetPort.Enabled := true;
      radioNetPasv.Enabled := true;
      radioNetPort.Enabled := true;
      Transmit := false;
      LogEvent('TCP转发服务已关闭');
    end
    else if IdUDPServerCCRecv.Active then begin
      IdUDPServerCCRecv.Active := False;
      editNetPort.Enabled := True;
      radioNetPort.Enabled := True;
      radioNetTransmit.Enabled := True;
      editNetPassword.Enabled := True;
      LogEvent('UDP监听关闭，停止接收网络弹幕');
    end
    else begin
      editNetHost.Enabled := true;
      radioNetPasv.Enabled := true;
      radioNetTransmit.Enabled := true;
      LogEvent('已关闭HTTP抓取，停止接收网络弹幕');
      RemoteTime := 0;
    end;
    Networking := false;
    btnNetStart.Caption := '开始通信(&M)';
  end
  else begin
    if radioNetPasv.Checked then begin
      port := StrToInt(editNetPort.Text);
      if (port < 1) or (port > 65535) then exit;
      try
        IdUDPServerCCRecv.Active := False;
        IdUDPServerCCRecv.Bindings.Clear;

        bind := IdUDPServerCCRecv.Bindings.Add;
        bind.IPVersion := Id_IPv4;
        bind.IP := '0.0.0.0';
        bind.Port := port;

        bind := IdUDPServerCCRecv.Bindings.Add;
        bind.IPVersion := Id_IPv6;
        bind.IP := '::';
        bind.Port := port;

        IdUDPServerCCRecv.ThreadClass := TUDPHandleThread;
        IdUDPServerCCRecv.ThreadedEvent := True;
        IdUDPServerCCRecv.Active := True;
        Networking := True;
        btnNetStart.Caption := '停止通信(&M)';
        radioNetPort.Enabled := False;
        radioNetTransmit.Enabled := False;
        editNetPort.Enabled := False;
        editNetPassword.Enabled := False;
        LogEvent('TCP监听启动于端口 ' + editNetPort.Text);
      except
        LogEvent('TCP服务器初始化失败，检查防火墙或端口冲突。');
      end;
    end
    else if radioNetPort.Checked then begin
      HTTPURL := editNetHost.Text;
      {LogEvent('测试Web服务器连接：' + editNetHost.Text);
      TestHTTPClient();}
      LogEvent('暂不支持。');
    end
    else begin
      LogEvent('暂不支持。');
    end;
  end;
end;

{procedure TfrmControl.TestHTTPClient();
var
  BadResponses : Array [0..2] of SmallInt;
  Response: WideString;
  i : Integer;
begin
  BadResponses[0] := 404;
  BadResponses[1] := 403;
  BadResponses[2] := 302;
  try
    HTTPClient.ConnectTimeout := 2000;
    HTTPClient.ReadTimeout := 2000;
    Response := HTTPClient.Get(HTTPURL+'?action=init&key='+editNetPassword.Text);
    HTTPClient.Disconnect;
    //LogEvent(Response);
    if AnsiStartsText('INT Namiko',Response) then begin
      i := Pos('=',Response);
      RemoteTime := Frac(UnixToDateTime(StrToInt(Copy(Response,i+1,Length(Response) - i)) - TimeZoneBias));
      RemoteTimeOffset := RemoteTime - Time();
      LogEvent('测试完成 服务器时间 '+TimeToStr(RemoteTime));
      TimerFetch.Enabled := true;
      Networking := true;
      btnNetStart.Caption := '停止通信(&M)';
      editNetHost.Enabled := false;
      radioNetPasv.Enabled := false;
      radioNetTransmit.Enabled := false;
    end
    else begin
      LogEvent('未识别的服务器数据，测试失败。');
    end;
  except
    HTTPClient.IOHandler.Close;
    if HTTPClient.Connected then HTTPClient.Disconnect;
    LogEvent('连接或读取超时，测试失败。');
  end;
end;}

procedure TfrmControl.cobNetCFontNameChange(Sender: TObject);
begin
  NetDefaultFontName := cobNetCFontName.Items.Strings[cobNetCFontName.ItemIndex];
end;

procedure TfrmControl.cobNetCFontSizeChange(Sender: TObject);
begin
  NetDefaultFontSize := 1.0 * StrToIntDef(cobNetCFontSize.Text,20);
end;

procedure TfrmControl.cobNetCFontBoldClick(Sender: TObject);
begin
  if cobNetCFontBold.Checked then NetDefaultFontStyle := 1 else NetDefaultFontStyle := 0;
end;

procedure TfrmControl.cobOfficialCFontNameChange(Sender: TObject);
begin
  OfficialFontName := cobOfficialCFontName.Items.Strings[cobOfficialCFontName.ItemIndex];
end;

procedure TfrmControl.cobOfficialCFontSizeChange(Sender: TObject);
begin
  OfficialFontSize := StrToIntDef(cobOfficialCFontSize.Text,20) * 1.0;
end;

procedure TfrmControl.cobOfficialCFontBoldClick(Sender: TObject);
begin
  OfficialFontStyle := IfThen(cobOfficialCFontBold.Checked,1,0);
end;

procedure TfrmControl.btnEscAllClick(Sender: TObject);
begin
  // Stop Thread and output a empty DC
end;

function TfrmControl.GetCommentCount(): Integer;
begin
  result := ListComments.Items.Count + ClearedItemCount;
end;

procedure TfrmControl.grpSpecialEffectsClick(Sender: TObject);
begin
  case grpSpecialEffects.ItemIndex of
    0 : editOfficialCommentPara.Enabled := true;
    1,2 : editOfficialCommentPara.Enabled := false;
  end;
  if editOfficialCommentPara.Enabled = false then editOfficialCommentPara.Text := '1';
end;

procedure TfrmControl.grpTimingClick(Sender: TObject);
begin
  case grpTiming.ItemIndex of
    0 : begin
      InternalTImeOffset := 0;
    end;
    1 : begin
      if RemoteTime <> 0 then InternalTimeOffset := RemoteTimeOffset else Application.MessageBox('远程时间未知','ERROR',MB_ICONEXCLAMATION);
    end;
    2 : begin
      InternalTimeOffset := StrToTimeDef(InputBox('更改时间轴','将内部时间修改为：   ',TimeToStr(Time())),Time())-Time();
    end;
  end;
end;

procedure TfrmControl.btnClearListClick(Sender: TObject);
begin
  SysReady := False;
  ListViewOffset := ListComments.Items.Count;
  ListComments.Items.Clear;
  SysReady := True;
end;

procedure TfrmControl.radioNetTransmitClick(Sender: TObject);
begin
  editNetHost.Enabled := false;
  editNetPort.Enabled := true;
end;

procedure TfrmControl.BtnFreezingClick(Sender: TObject);
begin
  if Freezing then begin
    InternalTimeOffset := InternalTimeOffset - (Time() - FreezingTime);
  end
  else begin
    FreezingTime := Time();
  end;
  Freezing := not Freezing;
end;

procedure TfrmControl.ListCommentsDblClick(Sender: TObject);
begin
  if ListComments.SelCount > 0 then begin
    try
      editOfficialComment.Text := ListComments.Selected.SubItems.Strings[T_TEXT];
    except
      Exit;
    end;
  end;
end;

procedure TfrmControl.ListCommentsKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
var
  CommentID: Integer;
begin
  if (Key = VK_Delete) and (ListComments.SelCount > 0) then begin
    ListComments.Selected.SubItems.Strings[T_TEXT] := '(已删除)';
    ListComments.Selected.Caption := 'R';
    CommentID := StrToInt(ListComments.Selected.SubItems.Strings[T_ID]);
    CommentPoolMutex.Acquire;
    try
      with CommentPool.Items[CommentID] do begin
        Content := '';
        Status := TCommentStatus.Removed;
      end;
    finally
      CommentPoolMutex.Release;
    end;
  end;
end;

initialization
  CoInitialize(nil);
  DefaultSA.nLength := SizeOf(TSecurityAttributes);
  DefaultSA.lpSecurityDescriptor := nil;
  DefaultSA.bInheritHandle := False;
  CommentPoolMutex := TMutex.Create(@DefaultSA,True,'main_pool_m');
  SharedConfigurationMutex := TMutex.Create(@DefaultSA,True,'shared_cfg_m');
  GraphicSharedMutex := TMutex.Create(@DefaultSA,True,'shared_gui_m');
  LiveCommentPoolMutex := TMutex.Create(@DefaultSA,True,'live_pool_m');
  UpdateQueueMutex := TMutex.Create(@DefaultSA,True,'render_queue_m');
  DispatchS := TSemaphore.Create(@DefaultSA,0,1024,'dispatch_s',False);
  UpdateS := TSemaphore.Create(@DefaultSA,0,512,'update_s',False);

finalization
  CommentPoolMutex.Free();
  SharedConfigurationMutex.Free();
  GraphicSharedMutex.Free();
  LiveCommentPoolMutex.Free();
  UpdateQueueMutex.Free();
  DispatchS.Free();
  UpdateS.Free();
  CoUninitialize();

end.
